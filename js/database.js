/**
 * Database module for SQLite operations using sql.js
 * Includes IndexedDB auto-save functionality
 */

const Database = {
    db: null,
    SQL: null,
    IDB_NAME: 'AccountingJournalDB',
    IDB_STORE: 'database',
    IDB_KEY: 'sqliteDb',

    /**
     * Initialize the database
     * @returns {Promise<void>}
     */
    async init() {
        this.SQL = await initSqlJs({
            locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.8.0/${file}`
        });

        const savedData = await this.loadFromIndexedDB();

        if (savedData) {
            this.db = new this.SQL.Database(savedData);
            this.migrateSchema();
            console.log('Database loaded from IndexedDB');
        } else {
            this.db = new this.SQL.Database();
            this.createSchema();
            console.log('New database created');
        }
    },

    /**
     * Create database schema
     */
    createSchema() {
        this.db.run(`
            CREATE TABLE IF NOT EXISTS category_folders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                folder_type TEXT NOT NULL DEFAULT 'payable',
                sort_order INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS categories (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                type TEXT DEFAULT 'both',
                is_monthly INTEGER DEFAULT 0,
                default_amount DECIMAL(10,2),
                default_type TEXT,
                folder_id INTEGER,
                cashflow_sort_order INTEGER DEFAULT 0,
                show_on_pl INTEGER DEFAULT 0,
                is_cogs INTEGER DEFAULT 0,
                is_depreciation INTEGER DEFAULT 0,
                is_sales_tax INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (folder_id) REFERENCES category_folders(id)
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS transactions (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                entry_date DATE NOT NULL,
                category_id INTEGER NOT NULL,
                item_description TEXT,
                amount DECIMAL(10,2) NOT NULL,
                pretax_amount DECIMAL(10,2),
                transaction_type TEXT NOT NULL,
                status TEXT NOT NULL DEFAULT 'pending',
                date_processed DATE,
                month_due TEXT,
                month_paid TEXT,
                payment_for_month TEXT,
                notes TEXT,
                source_type TEXT,
                source_id INTEGER,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (category_id) REFERENCES categories(id)
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS pl_overrides (
                category_id INTEGER,
                month TEXT,
                override_amount DECIMAL(10,2),
                PRIMARY KEY(category_id, month)
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS app_meta (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS cashflow_overrides (
                category_id INTEGER,
                month TEXT,
                override_amount DECIMAL(10,2),
                PRIMARY KEY(category_id, month)
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS balance_sheet_assets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                purchase_cost DECIMAL(10,2) NOT NULL,
                useful_life_months INTEGER NOT NULL,
                purchase_date DATE NOT NULL,
                salvage_value DECIMAL(10,2) DEFAULT 0,
                depreciation_method TEXT DEFAULT 'straight_line',
                dep_start_date DATE,
                is_depreciable INTEGER DEFAULT 1,
                linked_transaction_id INTEGER,
                notes TEXT,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS loans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                principal DECIMAL(10,2) NOT NULL,
                annual_rate DECIMAL(8,4) NOT NULL,
                term_months INTEGER NOT NULL,
                payments_per_year INTEGER NOT NULL DEFAULT 12,
                start_date DATE NOT NULL,
                first_payment_date DATE,
                notes TEXT,
                is_active INTEGER NOT NULL DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS loan_skipped_payments (
                loan_id INTEGER NOT NULL,
                payment_number INTEGER NOT NULL,
                PRIMARY KEY(loan_id, payment_number)
            )
        `);

        this.db.run(`
            CREATE TABLE IF NOT EXISTS loan_payment_overrides (
                loan_id INTEGER NOT NULL,
                payment_number INTEGER NOT NULL,
                override_amount DECIMAL(10,2) NOT NULL,
                PRIMARY KEY(loan_id, payment_number)
            )
        `);

        // Create default "Monthly Expenses" folder
        this.db.run('INSERT OR IGNORE INTO category_folders (name, folder_type, sort_order) VALUES (?, ?, ?)', ['Monthly Expenses', 'payable', 0]);

        const defaultCategories = [
            'General Income',
            'General Expense',
            'Loan',
            'Investment',
            'Salary',
            'Utilities',
            'Supplies'
        ];

        const stmt = this.db.prepare('INSERT OR IGNORE INTO categories (name) VALUES (?)');
        defaultCategories.forEach(cat => {
            stmt.run([cat]);
        });
        stmt.free();
    },

    /**
     * Migrate existing database schema (add new columns if missing)
     */
    migrateSchema() {
        try {
            this.db.exec('SELECT is_monthly FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN is_monthly INTEGER DEFAULT 0');
        }

        try {
            this.db.exec('SELECT payment_for_month FROM transactions LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE transactions ADD COLUMN payment_for_month TEXT');
        }

        // Add default_amount column to categories
        try {
            this.db.exec('SELECT default_amount FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN default_amount DECIMAL(10,2)');
        }

        // Add default_type column to categories
        try {
            this.db.exec('SELECT default_type FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN default_type TEXT');
        }

        // Add folder_id column to categories
        try {
            this.db.exec('SELECT folder_id FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN folder_id INTEGER');
        }

        // Create category_folders table if not exists
        this.db.run(`
            CREATE TABLE IF NOT EXISTS category_folders (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL UNIQUE,
                folder_type TEXT NOT NULL DEFAULT 'payable',
                sort_order INTEGER DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // Add folder_type column to category_folders if missing
        try {
            this.db.exec('SELECT folder_type FROM category_folders LIMIT 1');
        } catch (e) {
            this.db.run("ALTER TABLE category_folders ADD COLUMN folder_type TEXT NOT NULL DEFAULT 'payable'");
        }

        // Add pretax_amount column to transactions
        try {
            this.db.exec('SELECT pretax_amount FROM transactions LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE transactions ADD COLUMN pretax_amount DECIMAL(10,2)');
        }

        // Add cashflow_sort_order column to categories
        try {
            this.db.exec('SELECT cashflow_sort_order FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN cashflow_sort_order INTEGER DEFAULT 0');
        }

        // Add P&L flags to categories
        try {
            this.db.exec('SELECT show_on_pl FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN show_on_pl INTEGER DEFAULT 0');
        }
        try {
            this.db.exec('SELECT is_cogs FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN is_cogs INTEGER DEFAULT 0');
        }
        try {
            this.db.exec('SELECT is_depreciation FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN is_depreciation INTEGER DEFAULT 0');
        }

        // Create pl_overrides table for P&L manual overrides
        this.db.run(`
            CREATE TABLE IF NOT EXISTS pl_overrides (
                category_id INTEGER,
                month TEXT,
                override_amount DECIMAL(10,2),
                PRIMARY KEY(category_id, month)
            )
        `);

        // Ensure app_meta table exists
        this.db.run(`
            CREATE TABLE IF NOT EXISTS app_meta (
                key TEXT PRIMARY KEY,
                value TEXT
            )
        `);

        // Add is_sales_tax flag to categories
        try {
            this.db.exec('SELECT is_sales_tax FROM categories LIMIT 1');
        } catch (e) {
            this.db.run('ALTER TABLE categories ADD COLUMN is_sales_tax INTEGER DEFAULT 0');
        }

        // Create balance_sheet_assets table
        this.db.run(`
            CREATE TABLE IF NOT EXISTS balance_sheet_assets (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                purchase_cost DECIMAL(10,2) NOT NULL,
                useful_life_months INTEGER NOT NULL,
                purchase_date DATE NOT NULL,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // One-time migration: reset show_on_pl flags (semantics inverted from "show" to "hide")
        const migrated = this.db.exec("SELECT value FROM app_meta WHERE key = 'pl_hide_migration'");
        if (migrated.length === 0 || migrated[0].values.length === 0) {
            this.db.run('UPDATE categories SET show_on_pl = 0');
            this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('pl_hide_migration', '1')");
        }

        // === New columns on balance_sheet_assets ===
        try { this.db.exec('SELECT salvage_value FROM balance_sheet_assets LIMIT 1'); }
        catch (e) { this.db.run('ALTER TABLE balance_sheet_assets ADD COLUMN salvage_value DECIMAL(10,2) DEFAULT 0'); }

        try { this.db.exec('SELECT depreciation_method FROM balance_sheet_assets LIMIT 1'); }
        catch (e) { this.db.run("ALTER TABLE balance_sheet_assets ADD COLUMN depreciation_method TEXT DEFAULT 'straight_line'"); }

        try { this.db.exec('SELECT dep_start_date FROM balance_sheet_assets LIMIT 1'); }
        catch (e) { this.db.run('ALTER TABLE balance_sheet_assets ADD COLUMN dep_start_date DATE'); }

        try { this.db.exec('SELECT is_depreciable FROM balance_sheet_assets LIMIT 1'); }
        catch (e) { this.db.run('ALTER TABLE balance_sheet_assets ADD COLUMN is_depreciable INTEGER DEFAULT 1'); }

        try { this.db.exec('SELECT linked_transaction_id FROM balance_sheet_assets LIMIT 1'); }
        catch (e) { this.db.run('ALTER TABLE balance_sheet_assets ADD COLUMN linked_transaction_id INTEGER'); }

        try { this.db.exec('SELECT notes FROM balance_sheet_assets LIMIT 1'); }
        catch (e) { this.db.run('ALTER TABLE balance_sheet_assets ADD COLUMN notes TEXT'); }

        // === source_type and source_id on transactions ===
        try { this.db.exec('SELECT source_type FROM transactions LIMIT 1'); }
        catch (e) { this.db.run('ALTER TABLE transactions ADD COLUMN source_type TEXT'); }

        try { this.db.exec('SELECT source_id FROM transactions LIMIT 1'); }
        catch (e) { this.db.run('ALTER TABLE transactions ADD COLUMN source_id INTEGER'); }

        // === Create loans table ===
        this.db.run(`
            CREATE TABLE IF NOT EXISTS loans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                principal DECIMAL(10,2) NOT NULL,
                annual_rate DECIMAL(8,4) NOT NULL,
                term_months INTEGER NOT NULL,
                payments_per_year INTEGER NOT NULL DEFAULT 12,
                start_date DATE NOT NULL,
                notes TEXT,
                is_active INTEGER NOT NULL DEFAULT 1,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        `);

        // === Migrate loan_config JSON â†’ loans table row ===
        const loanMigrated = this.db.exec("SELECT value FROM app_meta WHERE key = 'loans_migration_v1'");
        if (loanMigrated.length === 0 || loanMigrated[0].values.length === 0) {
            const loanCfg = this.db.exec("SELECT value FROM app_meta WHERE key = 'loan_config'");
            if (loanCfg.length > 0 && loanCfg[0].values.length > 0) {
                try {
                    const cfg = JSON.parse(loanCfg[0].values[0][0]);
                    if (cfg && cfg.principal && cfg.start_date) {
                        const termMonths = (cfg.term_months) ? cfg.term_months : (cfg.term_years ? cfg.term_years * 12 : 0);
                        this.db.run(
                            `INSERT INTO loans (name, principal, annual_rate, term_months, payments_per_year, start_date)
                             VALUES (?, ?, ?, ?, ?, ?)`,
                            ['Primary Loan', cfg.principal, cfg.annual_rate, termMonths, cfg.payments_per_year || 12, cfg.start_date]
                        );
                    }
                } catch (e) {
                    console.warn('Failed to migrate loan_config:', e);
                }
            }
            this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('loans_migration_v1', '1')");
        }

        // === Create cashflow_overrides table ===
        this.db.run(`
            CREATE TABLE IF NOT EXISTS cashflow_overrides (
                category_id INTEGER,
                month TEXT,
                override_amount DECIMAL(10,2),
                PRIMARY KEY(category_id, month)
            )
        `);

        // === Create loan_skipped_payments table ===
        this.db.run(`
            CREATE TABLE IF NOT EXISTS loan_skipped_payments (
                loan_id INTEGER NOT NULL,
                payment_number INTEGER NOT NULL,
                PRIMARY KEY(loan_id, payment_number)
            )
        `);

        // === Create loan_payment_overrides table ===
        this.db.run(`
            CREATE TABLE IF NOT EXISTS loan_payment_overrides (
                loan_id INTEGER NOT NULL,
                payment_number INTEGER NOT NULL,
                override_amount DECIMAL(10,2) NOT NULL,
                PRIMARY KEY(loan_id, payment_number)
            )
        `);

        // === Add first_payment_date column to loans if missing ===
        try {
            this.db.exec("SELECT first_payment_date FROM loans LIMIT 1");
        } catch (e) {
            this.db.run("ALTER TABLE loans ADD COLUMN first_payment_date DATE");
        }
    },

    // ==================== FOLDER OPERATIONS ====================

    /**
     * Get all category folders
     * @returns {Array} Array of folder objects
     */
    getFolders() {
        const results = this.db.exec('SELECT * FROM category_folders ORDER BY sort_order ASC, name ASC');
        if (results.length === 0) return [];
        return this.rowsToObjects(results[0]);
    },

    /**
     * Add a new folder
     * @param {string} name - Folder name
     * @param {string} type - Folder type ('payable' or 'receivable')
     * @returns {number} New folder ID
     */
    addFolder(name, type = 'payable') {
        this.db.run('INSERT INTO category_folders (name, folder_type) VALUES (?, ?)', [name.trim(), type]);
        const result = this.db.exec('SELECT last_insert_rowid() as id');
        this.autoSave();
        return result[0].values[0][0];
    },

    /**
     * Update a folder
     * @param {number} id - Folder ID
     * @param {string} name - New name
     * @param {string} type - Folder type ('payable' or 'receivable')
     */
    updateFolder(id, name, type = 'payable') {
        this.db.run('UPDATE category_folders SET name = ?, folder_type = ? WHERE id = ?', [name.trim(), type, id]);
        this.autoSave();
    },

    /**
     * Delete a folder (moves its categories to unfiled)
     * @param {number} id - Folder ID
     */
    deleteFolder(id) {
        this.db.run('UPDATE categories SET folder_id = NULL WHERE folder_id = ?', [id]);
        this.db.run('DELETE FROM category_folders WHERE id = ?', [id]);
        this.autoSave();
    },

    /**
     * Get folder by ID
     * @param {number} id - Folder ID
     * @returns {Object|null} Folder object
     */
    getFolderById(id) {
        const results = this.db.exec('SELECT * FROM category_folders WHERE id = ?', [id]);
        if (results.length === 0) return null;
        return this.rowsToObjects(results[0])[0];
    },

    // ==================== CATEGORY OPERATIONS ====================

    /**
     * Get all categories with folder info
     * @returns {Array} Array of category objects
     */
    getCategories() {
        const results = this.db.exec(`
            SELECT c.*, cf.name as folder_name
            FROM categories c
            LEFT JOIN category_folders cf ON c.folder_id = cf.id
            ORDER BY cf.sort_order ASC, cf.name ASC, c.name ASC
        `);
        if (results.length === 0) return [];
        return this.rowsToObjects(results[0]);
    },

    /**
     * Add a new category
     * @param {string} name - Category name
     * @param {boolean} isMonthly - Whether this is a monthly payment category
     * @param {number|null} defaultAmount - Default amount for this category
     * @param {string|null} defaultType - Default type ('receivable' or 'payable')
     * @param {number|null} folderId - Folder ID
     * @returns {number} New category ID
     */
    addCategory(name, isMonthly = false, defaultAmount = null, defaultType = null, folderId = null, showOnPl = false, isCogs = false, isDepreciation = false, isSalesTax = false) {
        this.db.run(
            'INSERT INTO categories (name, is_monthly, default_amount, default_type, folder_id, show_on_pl, is_cogs, is_depreciation, is_sales_tax) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
            [name.trim(), isMonthly ? 1 : 0, defaultAmount, defaultType, folderId, showOnPl ? 1 : 0, isCogs ? 1 : 0, isDepreciation ? 1 : 0, isSalesTax ? 1 : 0]
        );
        const result = this.db.exec('SELECT last_insert_rowid() as id');
        this.autoSave();
        return result[0].values[0][0];
    },

    /**
     * Delete a category
     * @param {number} id - Category ID
     * @returns {boolean} Success (false if category is in use)
     */
    deleteCategory(id) {
        const inUse = this.db.exec('SELECT COUNT(*) as count FROM transactions WHERE category_id = ?', [id]);
        if (inUse[0].values[0][0] > 0) {
            return false;
        }
        this.db.run('DELETE FROM categories WHERE id = ?', [id]);
        this.autoSave();
        return true;
    },

    /**
     * Get category by ID
     * @param {number} id - Category ID
     * @returns {Object|null} Category object
     */
    getCategoryById(id) {
        const results = this.db.exec(`
            SELECT c.*, cf.name as folder_name
            FROM categories c
            LEFT JOIN category_folders cf ON c.folder_id = cf.id
            WHERE c.id = ?
        `, [id]);
        if (results.length === 0) return null;
        return this.rowsToObjects(results[0])[0];
    },

    /**
     * Update a category
     * @param {number} id - Category ID
     * @param {string} name - New name
     * @param {boolean} isMonthly - Whether this is a monthly payment category
     * @param {number|null} defaultAmount - Default amount
     * @param {string|null} defaultType - Default type
     * @param {number|null} folderId - Folder ID
     */
    updateCategory(id, name, isMonthly = false, defaultAmount = null, defaultType = null, folderId = null, showOnPl = false, isCogs = false, isDepreciation = false, isSalesTax = false) {
        this.db.run(
            'UPDATE categories SET name = ?, is_monthly = ?, default_amount = ?, default_type = ?, folder_id = ?, show_on_pl = ?, is_cogs = ?, is_depreciation = ?, is_sales_tax = ? WHERE id = ?',
            [name.trim(), isMonthly ? 1 : 0, defaultAmount, defaultType, folderId, showOnPl ? 1 : 0, isCogs ? 1 : 0, isDepreciation ? 1 : 0, isSalesTax ? 1 : 0, id]
        );
        this.autoSave();
    },

    /**
     * Get all categories in a specific folder
     * @param {number} folderId - Folder ID
     * @returns {Array} Array of category objects
     */
    getCategoriesByFolder(folderId) {
        const results = this.db.exec(
            'SELECT * FROM categories WHERE folder_id = ? ORDER BY name ASC',
            [folderId]
        );
        if (results.length === 0) return [];
        return this.rowsToObjects(results[0]);
    },

    /**
     * Update cashflow sort order for a list of category IDs
     * @param {Array<{id: number, sortOrder: number}>} orderList
     */
    updateCashflowSortOrder(orderList) {
        const stmt = this.db.prepare('UPDATE categories SET cashflow_sort_order = ? WHERE id = ?');
        orderList.forEach(({ id, sortOrder }) => {
            stmt.run([sortOrder, id]);
        });
        stmt.free();
        this.autoSave();
    },

    /**
     * Get count of transactions using a category
     * @param {number} categoryId - Category ID
     * @returns {number} Transaction count
     */
    getCategoryUsageCount(categoryId) {
        const result = this.db.exec('SELECT COUNT(*) as count FROM transactions WHERE category_id = ?', [categoryId]);
        return result[0].values[0][0];
    },

    // ==================== TRANSACTION OPERATIONS ====================

    /**
     * Get all transactions
     * @param {Object} filters - Optional filters
     * @returns {Array} Array of transaction objects
     */
    getTransactions(filters = {}) {
        let query = `
            SELECT t.*, c.name as category_name, c.is_monthly as category_is_monthly
            FROM transactions t
            LEFT JOIN categories c ON t.category_id = c.id
            WHERE 1=1
        `;
        const params = [];

        if (filters.type) {
            query += ' AND t.transaction_type = ?';
            params.push(filters.type);
        }

        if (filters.status) {
            query += ' AND t.status = ?';
            params.push(filters.status);
        }

        if (filters.month) {
            query += ' AND substr(t.entry_date, 1, 7) = ?';
            params.push(filters.month);
        }

        if (filters.folderId) {
            if (filters.folderId === 'unfiled') {
                query += ' AND c.folder_id IS NULL';
            } else {
                query += ' AND c.folder_id = ?';
                params.push(filters.folderId);
            }
        }

        if (filters.categoryId) {
            query += ' AND t.category_id = ?';
            params.push(filters.categoryId);
        }

        query += ' ORDER BY t.entry_date DESC, t.id DESC';

        const results = this.db.exec(query, params);
        if (results.length === 0) return [];

        return this.rowsToObjects(results[0]);
    },

    /**
     * Get a single transaction by ID
     * @param {number} id - Transaction ID
     * @returns {Object|null} Transaction object
     */
    getTransactionById(id) {
        const results = this.db.exec(`
            SELECT t.*, c.name as category_name, c.is_monthly as category_is_monthly
            FROM transactions t
            LEFT JOIN categories c ON t.category_id = c.id
            WHERE t.id = ?
        `, [id]);

        if (results.length === 0) return null;
        return this.rowsToObjects(results[0])[0];
    },

    /**
     * Add a new transaction
     * @param {Object} transaction - Transaction data
     * @returns {number} New transaction ID
     */
    addTransaction(transaction) {
        this.db.run(`
            INSERT INTO transactions
            (entry_date, category_id, item_description, amount, pretax_amount, transaction_type,
             status, date_processed, month_due, month_paid, payment_for_month, notes,
             source_type, source_id)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
            transaction.entry_date,
            transaction.category_id,
            transaction.item_description || null,
            transaction.amount,
            transaction.pretax_amount || null,
            transaction.transaction_type,
            transaction.status,
            transaction.date_processed || null,
            transaction.month_due || null,
            transaction.month_paid || null,
            transaction.payment_for_month || null,
            transaction.notes || null,
            transaction.source_type || null,
            transaction.source_id || null
        ]);

        const result = this.db.exec('SELECT last_insert_rowid() as id');
        this.autoSave();
        return result[0].values[0][0];
    },

    /**
     * Update a transaction
     * @param {number} id - Transaction ID
     * @param {Object} transaction - Transaction data
     */
    updateTransaction(id, transaction) {
        this.db.run(`
            UPDATE transactions SET
                entry_date = ?,
                category_id = ?,
                item_description = ?,
                amount = ?,
                pretax_amount = ?,
                transaction_type = ?,
                status = ?,
                date_processed = ?,
                month_due = ?,
                month_paid = ?,
                payment_for_month = ?,
                notes = ?,
                updated_at = CURRENT_TIMESTAMP
            WHERE id = ?
        `, [
            transaction.entry_date,
            transaction.category_id,
            transaction.item_description || null,
            transaction.amount,
            transaction.pretax_amount || null,
            transaction.transaction_type,
            transaction.status,
            transaction.date_processed || null,
            transaction.month_due || null,
            transaction.month_paid || null,
            transaction.payment_for_month || null,
            transaction.notes || null,
            id
        ]);
        this.autoSave();
    },

    /**
     * Update just the status of a transaction (for inline status changes)
     * @param {number} id - Transaction ID
     * @param {string} status - New status
     * @param {string} monthPaidValue - Optional month paid value (required for paid/received)
     */
    updateTransactionStatus(id, status, monthPaidValue = null) {
        if (status === 'pending') {
            // Reverting to pending: clear date_processed and month_paid
            this.db.run(`
                UPDATE transactions SET
                    status = ?,
                    date_processed = NULL,
                    month_paid = NULL,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `, [status, id]);
        } else {
            // Paid/received: set month_paid (required)
            const monthPaid = monthPaidValue || Utils.getCurrentMonth();
            this.db.run(`
                UPDATE transactions SET
                    status = ?,
                    month_paid = ?,
                    updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            `, [status, monthPaid, id]);
        }
        this.autoSave();
    },

    /**
     * Delete a transaction
     * @param {number} id - Transaction ID
     */
    deleteTransaction(id) {
        this.db.run('DELETE FROM transactions WHERE id = ?', [id]);
        this.autoSave();
    },

    // ==================== JOURNAL METADATA ====================

    /**
     * Get journal owner name
     * @returns {string} Journal owner name (empty string if not set)
     */
    getJournalOwner() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'journal_owner'");
        if (result.length === 0 || result[0].values.length === 0) {
            return '';
        }
        return result[0].values[0][0] || '';
    },

    /**
     * Set journal owner name
     * @param {string} owner - Owner/company name
     */
    setJournalOwner(owner) {
        this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('journal_owner', ?)", [owner]);
        this.autoSave();
    },

    /**
     * Get journal name (legacy support)
     * @returns {string} Journal name
     */
    getJournalName() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'journal_name'");
        if (result.length === 0 || result[0].values.length === 0) {
            return 'Accounting Journal';
        }
        return result[0].values[0][0];
    },

    /**
     * Set journal name (legacy support)
     * @param {string} name - Journal name
     */
    setJournalName(name) {
        this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('journal_name', ?)", [name]);
        this.autoSave();
    },

    // ==================== CALCULATIONS ====================

    /**
     * Calculate summary totals
     * @returns {Object} Summary object with cashBalance, receivables, payables
     */
    calculateSummary() {
        const receivedResult = this.db.exec(`
            SELECT COALESCE(SUM(amount), 0) as total
            FROM transactions
            WHERE transaction_type = 'receivable' AND status = 'received'
        `);
        const totalReceived = receivedResult[0].values[0][0];

        const paidResult = this.db.exec(`
            SELECT COALESCE(SUM(amount), 0) as total
            FROM transactions
            WHERE transaction_type = 'payable' AND status = 'paid'
        `);
        const totalPaid = paidResult[0].values[0][0];

        const receivablesResult = this.db.exec(`
            SELECT COALESCE(SUM(amount), 0) as total
            FROM transactions
            WHERE transaction_type = 'receivable' AND status = 'pending'
        `);
        const pendingReceivables = receivablesResult[0].values[0][0];

        const payablesResult = this.db.exec(`
            SELECT COALESCE(SUM(amount), 0) as total
            FROM transactions
            WHERE transaction_type = 'payable' AND status = 'pending'
        `);
        const pendingPayables = payablesResult[0].values[0][0];

        return {
            cashBalance: totalReceived - totalPaid,
            accountsReceivable: pendingReceivables,
            accountsPayable: pendingPayables
        };
    },

    /**
     * Check if there are any late payments in the completed transactions
     * @returns {Object} Object with lateReceivedAmount, latePaidAmount
     */
    checkLatePayments() {
        const lateReceivedResult = this.db.exec(`
            SELECT COALESCE(SUM(amount), 0) as total FROM transactions
            WHERE transaction_type = 'receivable'
            AND status = 'received'
            AND month_due IS NOT NULL
            AND month_paid IS NOT NULL
            AND month_paid > month_due
        `);
        const lateReceivedAmount = lateReceivedResult[0].values[0][0];

        const latePaidResult = this.db.exec(`
            SELECT COALESCE(SUM(amount), 0) as total FROM transactions
            WHERE transaction_type = 'payable'
            AND status = 'paid'
            AND month_due IS NOT NULL
            AND month_paid IS NOT NULL
            AND month_paid > month_due
        `);
        const latePaidAmount = latePaidResult[0].values[0][0];

        return {
            lateReceivedAmount,
            latePaidAmount,
            hasLateReceivables: lateReceivedAmount > 0,
            hasLatePayables: latePaidAmount > 0
        };
    },

    /**
     * Get monthly summary data (grouped by entry date)
     * @returns {Array} Array of monthly summary objects
     */
    getMonthlySummary() {
        const result = this.db.exec(`
            SELECT
                substr(entry_date, 1, 7) as month,
                SUM(CASE WHEN transaction_type = 'receivable' AND status = 'received' THEN amount ELSE 0 END) as received,
                SUM(CASE WHEN transaction_type = 'payable' AND status = 'paid' THEN amount ELSE 0 END) as paid,
                SUM(CASE WHEN transaction_type = 'receivable' AND status = 'pending' THEN amount ELSE 0 END) as pending_receivables,
                SUM(CASE WHEN transaction_type = 'payable' AND status = 'pending' THEN amount ELSE 0 END) as pending_payables,
                COUNT(*) as total_entries
            FROM transactions
            GROUP BY substr(entry_date, 1, 7)
            ORDER BY month DESC
        `);

        if (result.length === 0) return [];
        return this.rowsToObjects(result[0]);
    },

    /**
     * Get cash flow summary grouped by month_paid (when money actually moved)
     * Only includes completed transactions (paid/received), grouped by the month they were processed
     * @returns {Array} Array of cash flow summary objects
     */
    getCashFlowSummary() {
        const result = this.db.exec(`
            SELECT
                month_paid as month,
                SUM(CASE WHEN transaction_type = 'receivable' AND status = 'received' THEN amount ELSE 0 END) as cash_in,
                SUM(CASE WHEN transaction_type = 'payable' AND status = 'paid' THEN amount ELSE 0 END) as cash_out,
                COUNT(*) as total_entries
            FROM transactions
            WHERE month_paid IS NOT NULL
            AND status != 'pending'
            GROUP BY month_paid
            ORDER BY month DESC
        `);

        if (result.length === 0) return [];
        return this.rowsToObjects(result[0]);
    },

    /**
     * Get cash flow data broken down by category and month for spreadsheet view
     * @returns {Object} { months: string[], data: Object[] }
     */
    getCashFlowSpreadsheet() {
        // Get all distinct months from month_paid (sorted ASC)
        const monthsResult = this.db.exec(`
            SELECT DISTINCT month_paid as month FROM transactions
            WHERE month_paid IS NOT NULL AND status != 'pending'
            ORDER BY month ASC
        `);
        const months = monthsResult.length > 0 ? monthsResult[0].values.map(r => r[0]) : [];

        // Get per-category, per-month totals for completed transactions
        const dataResult = this.db.exec(`
            SELECT c.name as category_name, c.id as category_id,
                   t.transaction_type, t.month_paid as month,
                   SUM(t.amount) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.status != 'pending' AND t.month_paid IS NOT NULL
            GROUP BY c.id, t.month_paid, t.transaction_type
            ORDER BY c.cashflow_sort_order ASC, c.name ASC
        `);
        const data = dataResult.length > 0 ? this.rowsToObjects(dataResult[0]) : [];

        return { months, data };
    },

    /**
     * Get all transactions as flat data for CSV export
     * @returns {Array} Array of transaction objects with all fields
     */
    getTransactionsForExport() {
        const results = this.db.exec(`
            SELECT
                t.entry_date,
                c.name as category,
                t.transaction_type as type,
                t.amount,
                t.pretax_amount,
                t.status,
                t.month_due,
                t.month_paid,
                t.date_processed,
                t.payment_for_month,
                t.notes
            FROM transactions t
            LEFT JOIN categories c ON t.category_id = c.id
            ORDER BY t.entry_date DESC, t.id DESC
        `);

        if (results.length === 0) return [];
        return this.rowsToObjects(results[0]);
    },

    // ==================== PROFIT & LOSS ====================

    /**
     * Get P&L spreadsheet data (accrual-based: uses month_due, includes all statuses)
     * Revenue uses COALESCE(pretax_amount, amount) for receivable categories.
     * @returns {Object} { months, revenue, cogs, opex }
     */
    getPLSpreadsheet() {
        // Get all distinct months from month_due (accrual basis)
        const monthsResult = this.db.exec(`
            SELECT DISTINCT t.month_due as month FROM transactions t
            WHERE t.month_due IS NOT NULL
            ORDER BY month ASC
        `);
        const months = monthsResult.length > 0 ? monthsResult[0].values.map(r => r[0]) : [];

        // Revenue: receivable categories (not COGS, not hidden), using pretax_amount if available
        const revenueResult = this.db.exec(`
            SELECT c.id as category_id, c.name as category_name,
                   t.month_due as month,
                   SUM(COALESCE(t.pretax_amount, t.amount)) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.month_due IS NOT NULL
            AND t.transaction_type = 'receivable'
            AND c.is_cogs = 0
            AND c.show_on_pl != 1
            GROUP BY c.id, t.month_due
            ORDER BY c.cashflow_sort_order ASC, c.name ASC
        `);
        const revenue = revenueResult.length > 0 ? this.rowsToObjects(revenueResult[0]) : [];

        // COGS: is_cogs=1 categories (not hidden), accrual basis
        const cogsResult = this.db.exec(`
            SELECT c.id as category_id, c.name as category_name,
                   t.month_due as month,
                   SUM(t.amount) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.month_due IS NOT NULL
            AND c.is_cogs = 1
            AND c.show_on_pl != 1
            GROUP BY c.id, t.month_due
            ORDER BY c.cashflow_sort_order ASC, c.name ASC
        `);
        const cogs = cogsResult.length > 0 ? this.rowsToObjects(cogsResult[0]) : [];

        // OpEx: all payable categories that are not COGS, not depreciation, not sales tax, not hidden, accrual basis
        const opexResult = this.db.exec(`
            SELECT c.id as category_id, c.name as category_name,
                   t.month_due as month,
                   SUM(t.amount) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.month_due IS NOT NULL
            AND t.transaction_type = 'payable'
            AND c.is_cogs = 0
            AND c.is_depreciation = 0
            AND c.is_sales_tax = 0
            AND c.show_on_pl != 1
            GROUP BY c.id, t.month_due
            ORDER BY c.cashflow_sort_order ASC, c.name ASC
        `);
        const opex = opexResult.length > 0 ? this.rowsToObjects(opexResult[0]) : [];

        // Depreciation: categories flagged is_depreciation=1, shown regardless of show_on_pl
        // Values are manually entered via pl_overrides (no transaction aggregation)
        const depreciationResult = this.db.exec(`
            SELECT id as category_id, name as category_name
            FROM categories
            WHERE is_depreciation = 1
            ORDER BY cashflow_sort_order ASC, name ASC
        `);
        const depreciation = depreciationResult.length > 0 ? this.rowsToObjects(depreciationResult[0]) : [];

        // Computed asset depreciation and loan interest by month
        const assetDeprByMonth = this.getAssetDepreciationByMonth(null);
        const loanInterestByMonth = this.getLoanInterestByMonth(null);

        // Merge their month keys into the master months array
        const allMonths = new Set(months);
        Object.keys(assetDeprByMonth).forEach(m => allMonths.add(m));
        Object.keys(loanInterestByMonth).forEach(m => allMonths.add(m));
        const mergedMonths = Array.from(allMonths).sort();

        return { months: mergedMonths, revenue, cogs, opex, depreciation, assetDeprByMonth, loanInterestByMonth };
    },

    /**
     * Get P&L tax mode setting
     * @returns {string} 'corporate' or 'passthrough'
     */
    getPLTaxMode() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'pl_tax_mode'");
        if (result.length === 0 || result[0].values.length === 0) {
            return 'corporate';
        }
        return result[0].values[0][0] || 'corporate';
    },

    /**
     * Set P&L tax mode setting
     * @param {string} mode - 'corporate' or 'passthrough'
     */
    setPLTaxMode(mode) {
        this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('pl_tax_mode', ?)", [mode]);
        this.autoSave();
    },

    // ==================== THEME SETTINGS ====================

    /**
     * Get theme preset name
     * @returns {string} Preset name (default, ocean, forest, sunset, midnight, custom)
     */
    getThemePreset() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'theme_preset'");
        if (result.length === 0 || result[0].values.length === 0) return 'default';
        return result[0].values[0][0] || 'default';
    },

    /**
     * Set theme preset name
     * @param {string} name - Preset name
     */
    setThemePreset(name) {
        this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('theme_preset', ?)", [name]);
        this.autoSave();
    },

    /**
     * Get custom theme colors
     * @returns {Object|null} Color object {c1, c2, c3, c4} or null
     */
    getThemeColors() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'theme_colors'");
        if (result.length === 0 || result[0].values.length === 0) return null;
        try {
            return JSON.parse(result[0].values[0][0]);
        } catch (e) {
            return null;
        }
    },

    /**
     * Set custom theme colors
     * @param {Object} colors - Color object {c1, c2, c3, c4}
     */
    setThemeColors(colors) {
        this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('theme_colors', ?)", [JSON.stringify(colors)]);
        this.autoSave();
    },

    /**
     * Get dark mode setting
     * @returns {boolean} True if dark mode enabled
     */
    getThemeDark() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'theme_dark'");
        if (result.length === 0 || result[0].values.length === 0) return false;
        return result[0].values[0][0] === '1';
    },

    /**
     * Set dark mode setting
     * @param {boolean} isDark - True for dark mode
     */
    setThemeDark(isDark) {
        this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('theme_dark', ?)", [isDark ? '1' : '0']);
        this.autoSave();
    },

    // ==================== FIXED ASSETS ====================

    /**
     * Get all fixed assets
     * @returns {Array} Array of fixed asset objects
     */
    getFixedAssets() {
        const results = this.db.exec('SELECT * FROM balance_sheet_assets ORDER BY purchase_date ASC, name ASC');
        if (results.length === 0) return [];
        return this.rowsToObjects(results[0]);
    },

    /**
     * Add a fixed asset
     * @param {string} name - Asset name
     * @param {number} purchaseCost - Purchase cost
     * @param {number} usefulLifeMonths - Useful life in months
     * @param {string} purchaseDate - Purchase date (YYYY-MM-DD)
     * @param {number} salvageValue - Salvage value
     * @param {string} depreciationMethod - 'straight_line' | 'double_declining' | 'none'
     * @param {string|null} depStartDate - Depreciation start date (YYYY-MM-DD) or null
     * @param {boolean} isDepreciable - Whether the asset depreciates
     * @param {string|null} notes - Notes
     * @returns {number} New asset ID
     */
    addFixedAsset(name, purchaseCost, usefulLifeMonths, purchaseDate, salvageValue = 0, depreciationMethod = 'straight_line', depStartDate = null, isDepreciable = true, notes = null) {
        this.db.run(
            `INSERT INTO balance_sheet_assets (name, purchase_cost, useful_life_months, purchase_date, salvage_value, depreciation_method, dep_start_date, is_depreciable, notes)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`,
            [name.trim(), purchaseCost, usefulLifeMonths, purchaseDate, salvageValue, depreciationMethod, depStartDate, isDepreciable ? 1 : 0, notes]
        );
        const result = this.db.exec('SELECT last_insert_rowid() as id');
        this.autoSave();
        return result[0].values[0][0];
    },

    /**
     * Update a fixed asset
     * @param {number} id - Asset ID
     * @param {string} name - Asset name
     * @param {number} purchaseCost - Purchase cost
     * @param {number} usefulLifeMonths - Useful life in months
     * @param {string} purchaseDate - Purchase date (YYYY-MM-DD)
     * @param {number} salvageValue - Salvage value
     * @param {string} depreciationMethod - Depreciation method
     * @param {string|null} depStartDate - Depreciation start date
     * @param {boolean} isDepreciable - Whether the asset depreciates
     * @param {string|null} notes - Notes
     */
    updateFixedAsset(id, name, purchaseCost, usefulLifeMonths, purchaseDate, salvageValue = 0, depreciationMethod = 'straight_line', depStartDate = null, isDepreciable = true, notes = null) {
        this.db.run(
            `UPDATE balance_sheet_assets SET name = ?, purchase_cost = ?, useful_life_months = ?, purchase_date = ?,
             salvage_value = ?, depreciation_method = ?, dep_start_date = ?, is_depreciable = ?, notes = ? WHERE id = ?`,
            [name.trim(), purchaseCost, usefulLifeMonths, purchaseDate, salvageValue, depreciationMethod, depStartDate, isDepreciable ? 1 : 0, notes, id]
        );
        this.autoSave();
    },

    /**
     * Delete a fixed asset (and its linked transaction if any)
     * @param {number} id - Asset ID
     */
    deleteFixedAsset(id) {
        // Remove linked transaction
        this.db.run("DELETE FROM transactions WHERE source_type = 'asset_purchase' AND source_id = ?", [id]);
        this.db.run('DELETE FROM balance_sheet_assets WHERE id = ?', [id]);
        this.autoSave();
    },

    /**
     * Get a fixed asset by ID
     * @param {number} id - Asset ID
     * @returns {Object|null} Asset object
     */
    getFixedAssetById(id) {
        const results = this.db.exec('SELECT * FROM balance_sheet_assets WHERE id = ?', [id]);
        if (results.length === 0) return null;
        return this.rowsToObjects(results[0])[0];
    },

    /**
     * Link a transaction ID to a fixed asset
     * @param {number} assetId - Asset ID
     * @param {number} transactionId - Transaction ID
     */
    linkTransactionToAsset(assetId, transactionId) {
        this.db.run('UPDATE balance_sheet_assets SET linked_transaction_id = ? WHERE id = ?', [transactionId, assetId]);
        this.autoSave();
    },

    /**
     * Get aggregated asset depreciation by month.
     * For each depreciable asset, computes its schedule and aggregates.
     * @param {string|null} asOfMonth - If provided, only returns months <= asOfMonth
     * @returns {Object} Map of { [YYYY-MM]: totalDepreciation }
     */
    getAssetDepreciationByMonth(asOfMonth) {
        const assets = this.getFixedAssets();
        const result = {};

        assets.forEach(asset => {
            const schedule = Utils.computeDepreciationSchedule(asset);
            Object.entries(schedule).forEach(([month, amount]) => {
                if (asOfMonth && month > asOfMonth) return;
                result[month] = Math.round(((result[month] || 0) + amount) * 100) / 100;
            });
        });

        return result;
    },

    // ==================== LOANS ====================

    /**
     * Get all active loans
     * @returns {Array} Array of loan objects
     */
    getLoans() {
        const results = this.db.exec('SELECT * FROM loans WHERE is_active = 1 ORDER BY start_date ASC');
        if (results.length === 0) return [];
        return this.rowsToObjects(results[0]);
    },

    /**
     * Get a loan by ID
     * @param {number} id - Loan ID
     * @returns {Object|null} Loan object
     */
    getLoanById(id) {
        const results = this.db.exec('SELECT * FROM loans WHERE id = ?', [id]);
        if (results.length === 0) return null;
        return this.rowsToObjects(results[0])[0];
    },

    /**
     * Add a new loan
     * @param {Object} params - { name, principal, annual_rate, term_months, payments_per_year, start_date, notes }
     * @returns {number} New loan ID
     */
    addLoan(params) {
        this.db.run(
            `INSERT INTO loans (name, principal, annual_rate, term_months, payments_per_year, start_date, first_payment_date, notes)
             VALUES (?, ?, ?, ?, ?, ?, ?, ?)`,
            [params.name.trim(), params.principal, params.annual_rate, params.term_months, params.payments_per_year || 12, params.start_date, params.first_payment_date || null, params.notes || null]
        );
        const result = this.db.exec('SELECT last_insert_rowid() as id');
        this.autoSave();
        return result[0].values[0][0];
    },

    /**
     * Update a loan
     * @param {number} id - Loan ID
     * @param {Object} params - Fields to update
     */
    updateLoan(id, params) {
        this.db.run(
            `UPDATE loans SET name = ?, principal = ?, annual_rate = ?, term_months = ?,
             payments_per_year = ?, start_date = ?, first_payment_date = ?, notes = ? WHERE id = ?`,
            [params.name.trim(), params.principal, params.annual_rate, params.term_months, params.payments_per_year || 12, params.start_date, params.first_payment_date || null, params.notes || null, id]
        );
        this.autoSave();
    },

    /**
     * Permanently delete a loan and all associated data
     * @param {number} id - Loan ID
     */
    deleteLoan(id) {
        this.db.run('DELETE FROM loans WHERE id = ?', [id]);
        this.db.run('DELETE FROM loan_skipped_payments WHERE loan_id = ?', [id]);
        this.db.run('DELETE FROM loan_payment_overrides WHERE loan_id = ?', [id]);
        this.autoSave();
    },

    /**
     * Get skipped payment numbers for a loan
     * @param {number} loanId
     * @returns {Set<number>} Set of skipped payment numbers
     */
    getSkippedPayments(loanId) {
        const results = this.db.exec('SELECT payment_number FROM loan_skipped_payments WHERE loan_id = ?', [loanId]);
        const set = new Set();
        if (results.length > 0) {
            results[0].values.forEach(row => set.add(row[0]));
        }
        return set;
    },

    /**
     * Toggle a loan payment as skipped/unskipped
     * @param {number} loanId
     * @param {number} paymentNumber
     */
    toggleSkipLoanPayment(loanId, paymentNumber) {
        const existing = this.db.exec(
            'SELECT 1 FROM loan_skipped_payments WHERE loan_id = ? AND payment_number = ?',
            [loanId, paymentNumber]
        );
        if (existing.length > 0 && existing[0].values.length > 0) {
            this.db.run('DELETE FROM loan_skipped_payments WHERE loan_id = ? AND payment_number = ?', [loanId, paymentNumber]);
        } else {
            this.db.run('INSERT INTO loan_skipped_payments (loan_id, payment_number) VALUES (?, ?)', [loanId, paymentNumber]);
        }
        this.autoSave();
    },

    /**
     * Get all payment overrides for a loan
     * @param {number} loanId
     * @returns {Object} Map of paymentNumber => override_amount
     */
    getLoanPaymentOverrides(loanId) {
        const results = this.db.exec('SELECT payment_number, override_amount FROM loan_payment_overrides WHERE loan_id = ?', [loanId]);
        const map = {};
        if (results.length > 0) {
            results[0].values.forEach(([num, amt]) => { map[num] = amt; });
        }
        return map;
    },

    /**
     * Set or remove a payment override
     * @param {number} loanId
     * @param {number} paymentNumber
     * @param {number|null} amount - null to remove override
     */
    setLoanPaymentOverride(loanId, paymentNumber, amount) {
        if (amount === null || amount === undefined) {
            this.db.run('DELETE FROM loan_payment_overrides WHERE loan_id = ? AND payment_number = ?', [loanId, paymentNumber]);
        } else {
            this.db.run(
                'INSERT OR REPLACE INTO loan_payment_overrides (loan_id, payment_number, override_amount) VALUES (?, ?, ?)',
                [loanId, paymentNumber, amount]
            );
        }
        this.autoSave();
    },

    /**
     * Get aggregated loan interest by month across all active loans.
     * @param {string|null} asOfMonth - If provided, only returns months <= asOfMonth
     * @returns {Object} Map of { [YYYY-MM]: totalInterest }
     */
    getLoanInterestByMonth(asOfMonth) {
        const loans = this.getLoans();
        const result = {};

        loans.forEach(loan => {
            const skipped = this.getSkippedPayments(loan.id);
            const overrides = this.getLoanPaymentOverrides(loan.id);
            const schedule = Utils.computeAmortizationSchedule({
                principal: loan.principal,
                annual_rate: loan.annual_rate,
                term_months: loan.term_months,
                payments_per_year: loan.payments_per_year,
                start_date: loan.start_date,
                first_payment_date: loan.first_payment_date
            }, skipped, overrides);

            schedule.forEach(entry => {
                if (asOfMonth && entry.month > asOfMonth) return;
                if (entry.skipped) return;
                result[entry.month] = Math.round(((result[entry.month] || 0) + entry.interest) * 100) / 100;
            });
        });

        return result;
    },

    // ==================== EQUITY & LOAN CONFIG ====================

    /**
     * Get equity config (common stock par, shares, APIC)
     * @returns {Object} { common_stock_par: number, common_stock_shares: number, apic: number }
     */
    getEquityConfig() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'equity_config'");
        if (result.length === 0 || result[0].values.length === 0) {
            return { common_stock_par: 0, common_stock_shares: 0, apic: 0 };
        }
        try {
            return JSON.parse(result[0].values[0][0]);
        } catch (e) {
            return { common_stock_par: 0, common_stock_shares: 0, apic: 0 };
        }
    },

    /**
     * Set equity config
     * @param {Object} config - { common_stock_par, common_stock_shares, apic }
     */
    setEquityConfig(config) {
        this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('equity_config', ?)", [JSON.stringify(config)]);
        this.autoSave();
    },

    /**
     * Get loan config (single loan)
     * @returns {Object|null} { principal, annual_rate, term_years, payments_per_year, start_date } or null
     */
    getLoanConfig() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'loan_config'");
        if (result.length === 0 || result[0].values.length === 0) return null;
        try {
            return JSON.parse(result[0].values[0][0]);
        } catch (e) {
            return null;
        }
    },

    /**
     * Set loan config (kept for backward compat)
     * @param {Object|null} config - Loan config object or null to clear
     */
    setLoanConfig(config) {
        if (config === null) {
            this.db.run("DELETE FROM app_meta WHERE key = 'loan_config'");
        } else {
            this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('loan_config', ?)", [JSON.stringify(config)]);
        }
        this.autoSave();
    },

    // ==================== TAB ORDER ====================

    /**
     * Get saved tab order
     * @returns {Array|null} Array of tab names or null if not set
     */
    getTabOrder() {
        const result = this.db.exec("SELECT value FROM app_meta WHERE key = 'tab_order'");
        if (result.length === 0 || result[0].values.length === 0) return null;
        try {
            return JSON.parse(result[0].values[0][0]);
        } catch (e) {
            return null;
        }
    },

    /**
     * Save tab order
     * @param {Array} order - Array of tab name strings
     */
    setTabOrder(order) {
        this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('tab_order', ?)", [JSON.stringify(order)]);
        this.autoSave();
    },

    // ==================== TIMELINE ====================

    /**
     * Get timeline settings
     * @returns {Object} { start: 'YYYY-MM' | null, end: 'YYYY-MM' | null }
     */
    getTimeline() {
        const startResult = this.db.exec("SELECT value FROM app_meta WHERE key = 'timeline_start'");
        const endResult = this.db.exec("SELECT value FROM app_meta WHERE key = 'timeline_end'");
        return {
            start: (startResult.length > 0 && startResult[0].values.length > 0) ? startResult[0].values[0][0] : null,
            end: (endResult.length > 0 && endResult[0].values.length > 0) ? endResult[0].values[0][0] : null
        };
    },

    /**
     * Set timeline start month
     * @param {string|null} month - 'YYYY-MM' or null to clear
     */
    setTimelineStart(month) {
        if (month) {
            this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('timeline_start', ?)", [month]);
        } else {
            this.db.run("DELETE FROM app_meta WHERE key = 'timeline_start'");
        }
        this.autoSave();
    },

    /**
     * Set timeline end month
     * @param {string|null} month - 'YYYY-MM' or null to clear
     */
    setTimelineEnd(month) {
        if (month) {
            this.db.run("INSERT OR REPLACE INTO app_meta (key, value) VALUES ('timeline_end', ?)", [month]);
        } else {
            this.db.run("DELETE FROM app_meta WHERE key = 'timeline_end'");
        }
        this.autoSave();
    },

    // ==================== CASH FLOW OVERRIDES ====================

    /**
     * Get all cash flow overrides
     * @returns {Object} Map of "categoryId-month" => override_amount
     */
    getAllCashFlowOverrides() {
        const results = this.db.exec('SELECT category_id, month, override_amount FROM cashflow_overrides');
        if (results.length === 0) return {};
        const overrides = {};
        this.rowsToObjects(results[0]).forEach(row => {
            overrides[`${row.category_id}-${row.month}`] = row.override_amount;
        });
        return overrides;
    },

    /**
     * Set a cash flow override value for a category+month
     * @param {number} categoryId - Category ID
     * @param {string} month - Month (YYYY-MM)
     * @param {number|null} amount - Override amount (null to remove)
     */
    setCashFlowOverride(categoryId, month, amount) {
        if (amount === null || amount === '') {
            this.db.run('DELETE FROM cashflow_overrides WHERE category_id = ? AND month = ?', [categoryId, month]);
        } else {
            this.db.run(
                'INSERT OR REPLACE INTO cashflow_overrides (category_id, month, override_amount) VALUES (?, ?, ?)',
                [categoryId, month, parseFloat(amount)]
            );
        }
        this.autoSave();
    },

    // ==================== BALANCE SHEET QUERIES ====================

    /**
     * Get cash balance as of a given month (sum of received - sum of paid where month_paid <= asOfMonth)
     * @param {string} asOfMonth - Month in YYYY-MM format
     * @returns {number} Cash balance
     */
    getCashAsOf(asOfMonth) {
        const result = this.db.exec(`
            SELECT
                COALESCE(SUM(CASE WHEN transaction_type = 'receivable' AND status = 'received' THEN amount ELSE 0 END), 0)
                - COALESCE(SUM(CASE WHEN transaction_type = 'payable' AND status = 'paid' THEN amount ELSE 0 END), 0) as cash
            FROM transactions
            WHERE month_paid IS NOT NULL AND month_paid <= ?
        `, [asOfMonth]);
        return result[0].values[0][0];
    },

    /**
     * Get accounts receivable as of a given month
     * (receivable transactions where month_due <= asOfMonth AND still unpaid as of that month)
     * @param {string} asOfMonth - Month in YYYY-MM format
     * @returns {number} AR balance
     */
    getAccountsReceivableAsOf(asOfMonth) {
        const result = this.db.exec(`
            SELECT COALESCE(SUM(amount), 0) as total
            FROM transactions
            WHERE transaction_type = 'receivable'
            AND month_due IS NOT NULL
            AND month_due <= ?
            AND (status = 'pending' OR (status = 'received' AND month_paid > ?))
        `, [asOfMonth, asOfMonth]);
        return result[0].values[0][0];
    },

    /**
     * Get accounts payable as of a given month (non-sales-tax categories)
     * @param {string} asOfMonth - Month in YYYY-MM format
     * @returns {number} AP balance
     */
    getAccountsPayableAsOf(asOfMonth) {
        const result = this.db.exec(`
            SELECT COALESCE(SUM(t.amount), 0) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.transaction_type = 'payable'
            AND c.is_sales_tax = 0
            AND t.month_due IS NOT NULL
            AND t.month_due <= ?
            AND (t.status = 'pending' OR (t.status = 'paid' AND t.month_paid > ?))
        `, [asOfMonth, asOfMonth]);
        return result[0].values[0][0];
    },

    /**
     * Get sales tax payable as of a given month (only sales tax categories)
     * @param {string} asOfMonth - Month in YYYY-MM format
     * @returns {number} Sales tax payable balance
     */
    getSalesTaxPayableAsOf(asOfMonth) {
        const result = this.db.exec(`
            SELECT COALESCE(SUM(t.amount), 0) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.transaction_type = 'payable'
            AND c.is_sales_tax = 1
            AND t.month_due IS NOT NULL
            AND t.month_due <= ?
            AND (t.status = 'pending' OR (t.status = 'paid' AND t.month_paid > ?))
        `, [asOfMonth, asOfMonth]);
        return result[0].values[0][0];
    },

    /**
     * Get accounts receivable broken down by category as of a given month
     * @param {string} asOfMonth - Month in YYYY-MM format
     * @returns {Array} [{category_id, category_name, total}]
     */
    getARByCategory(asOfMonth) {
        const results = this.db.exec(`
            SELECT c.id as category_id, c.name as category_name,
                   COALESCE(SUM(t.amount), 0) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.transaction_type = 'receivable'
            AND t.month_due IS NOT NULL
            AND t.month_due <= ?
            AND (t.status = 'pending' OR (t.status = 'received' AND t.month_paid > ?))
            GROUP BY c.id, c.name
            HAVING total > 0
            ORDER BY c.name ASC
        `, [asOfMonth, asOfMonth]);
        if (results.length === 0) return [];
        return this.rowsToObjects(results[0]);
    },

    /**
     * Get accounts payable broken down by category as of a given month (excludes sales tax)
     * @param {string} asOfMonth - Month in YYYY-MM format
     * @returns {Array} [{category_id, category_name, total}]
     */
    getAPByCategory(asOfMonth) {
        const results = this.db.exec(`
            SELECT c.id as category_id, c.name as category_name,
                   COALESCE(SUM(t.amount), 0) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.transaction_type = 'payable'
            AND c.is_sales_tax = 0
            AND t.month_due IS NOT NULL
            AND t.month_due <= ?
            AND (t.status = 'pending' OR (t.status = 'paid' AND t.month_paid > ?))
            GROUP BY c.id, c.name
            HAVING total > 0
            ORDER BY c.name ASC
        `, [asOfMonth, asOfMonth]);
        if (results.length === 0) return [];
        return this.rowsToObjects(results[0]);
    },

    /**
     * Get retained earnings as of a given month (cumulative P&L net income through asOfMonth).
     * This recomputes P&L with overrides to match what the P&L statement shows.
     * @param {string} asOfMonth - Month in YYYY-MM format
     * @param {string} taxMode - 'corporate' or 'passthrough'
     * @returns {number} Retained earnings (cumulative net income after tax)
     */
    getRetainedEarningsAsOf(asOfMonth, taxMode) {
        // Get all months up to and including asOfMonth (from transactions)
        const monthsResult = this.db.exec(`
            SELECT DISTINCT t.month_due as month FROM transactions t
            WHERE t.month_due IS NOT NULL AND t.month_due <= ?
            ORDER BY month ASC
        `, [asOfMonth]);
        const txMonths = monthsResult.length > 0 ? monthsResult[0].values.map(r => r[0]) : [];

        // Also include months from asset depreciation and loan interest
        const assetDeprByMonth = this.getAssetDepreciationByMonth(asOfMonth);
        const loanInterestByMonth = this.getLoanInterestByMonth(asOfMonth);

        const allMonths = new Set(txMonths);
        Object.keys(assetDeprByMonth).forEach(m => allMonths.add(m));
        Object.keys(loanInterestByMonth).forEach(m => allMonths.add(m));
        const months = Array.from(allMonths).sort();

        if (months.length === 0) return 0;

        const overrides = this.getAllPLOverrides();

        // Helper: get value with override
        const getVal = (catId, month, computed) => {
            const key = `${catId}-${month}`;
            return (key in overrides) ? overrides[key] : computed;
        };

        // Revenue per category per month (accrual, pretax)
        const revenueResult = this.db.exec(`
            SELECT c.id as category_id, t.month_due as month,
                   SUM(COALESCE(t.pretax_amount, t.amount)) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.month_due IS NOT NULL AND t.month_due <= ?
            AND t.transaction_type = 'receivable'
            AND c.is_cogs = 0 AND c.show_on_pl != 1
            GROUP BY c.id, t.month_due
        `, [asOfMonth]);
        const revenue = revenueResult.length > 0 ? this.rowsToObjects(revenueResult[0]) : [];

        // COGS
        const cogsResult = this.db.exec(`
            SELECT c.id as category_id, t.month_due as month, SUM(t.amount) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.month_due IS NOT NULL AND t.month_due <= ?
            AND c.is_cogs = 1 AND c.show_on_pl != 1
            GROUP BY c.id, t.month_due
        `, [asOfMonth]);
        const cogs = cogsResult.length > 0 ? this.rowsToObjects(cogsResult[0]) : [];

        // OpEx (non-COGS, non-depreciation, non-sales-tax payables)
        const opexResult = this.db.exec(`
            SELECT c.id as category_id, t.month_due as month, SUM(t.amount) as total
            FROM transactions t
            JOIN categories c ON t.category_id = c.id
            WHERE t.month_due IS NOT NULL AND t.month_due <= ?
            AND t.transaction_type = 'payable'
            AND c.is_cogs = 0 AND c.is_depreciation = 0 AND c.is_sales_tax = 0 AND c.show_on_pl != 1
            GROUP BY c.id, t.month_due
        `, [asOfMonth]);
        const opex = opexResult.length > 0 ? this.rowsToObjects(opexResult[0]) : [];

        // Depreciation categories (values from overrides only)
        const deprResult = this.db.exec(`SELECT id as category_id FROM categories WHERE is_depreciation = 1`);
        const deprCats = deprResult.length > 0 ? deprResult[0].values.map(r => r[0]) : [];

        // Build lookup maps
        const buildMap = (rows) => {
            const map = {};
            rows.forEach(r => {
                const key = `${r.category_id}-${r.month}`;
                map[key] = (map[key] || 0) + r.total;
            });
            return map;
        };

        const revMap = buildMap(revenue);
        const cogsMap = buildMap(cogs);
        const opexMap = buildMap(opex);

        // Compute cumulative net income
        const round2 = (v) => Math.round(v * 100) / 100;
        let cumulative = 0;

        // Get unique category IDs per section from transactions
        const revCatIds = [...new Set(revenue.map(r => r.category_id))];
        const cogsCatIds = [...new Set(cogs.map(r => r.category_id))];
        const opexCatIds = [...new Set(opex.map(r => r.category_id))];

        // Also include categories that have overrides but no transactions
        // (override-only categories would otherwise be missed)
        Object.keys(overrides).forEach(key => {
            const [catIdStr] = key.split('-');
            const catId = parseInt(catIdStr);
            if (catId < 0) return; // skip tax override key (-1)
            if (!revCatIds.includes(catId) && !cogsCatIds.includes(catId) &&
                !opexCatIds.includes(catId) && !deprCats.includes(catId)) {
                // Check if this category is an opex category (non-hidden, non-cogs, non-depr, non-sales-tax payable-eligible)
                const catResult = this.db.exec(`
                    SELECT id FROM categories
                    WHERE id = ? AND is_cogs = 0 AND is_depreciation = 0 AND is_sales_tax = 0 AND show_on_pl != 1
                `, [catId]);
                if (catResult.length > 0 && catResult[0].values.length > 0) {
                    opexCatIds.push(catId);
                }
            }
        });

        months.forEach(month => {
            let monthRev = 0;
            revCatIds.forEach(catId => {
                monthRev += getVal(catId, month, revMap[`${catId}-${month}`] || 0);
            });

            let monthCogs = 0;
            cogsCatIds.forEach(catId => {
                monthCogs += getVal(catId, month, cogsMap[`${catId}-${month}`] || 0);
            });

            let monthOpex = 0;
            opexCatIds.forEach(catId => {
                monthOpex += getVal(catId, month, opexMap[`${catId}-${month}`] || 0);
            });

            // Depreciation from overrides (manual depreciation categories)
            deprCats.forEach(catId => {
                monthOpex += getVal(catId, month, 0);
            });

            // Asset depreciation (computed from fixed assets)
            if (assetDeprByMonth[month]) {
                monthOpex += assetDeprByMonth[month];
            }

            // Loan interest (computed from active loans)
            if (loanInterestByMonth[month]) {
                monthOpex += loanInterestByMonth[month];
            }

            const nibt = round2(monthRev - monthCogs - monthOpex);

            let tax = 0;
            if (taxMode === 'corporate') {
                const autoTax = round2(nibt > 0 ? nibt * 0.21 : 0);
                tax = getVal(-1, month, autoTax);
            }

            cumulative = round2(cumulative + nibt - tax);
        });

        return cumulative;
    },

    /**
     * Get all P&L overrides
     * @returns {Object} Map of "categoryId-month" => override_amount
     */
    getAllPLOverrides() {
        const results = this.db.exec('SELECT category_id, month, override_amount FROM pl_overrides');
        if (results.length === 0) return {};
        const overrides = {};
        this.rowsToObjects(results[0]).forEach(row => {
            overrides[`${row.category_id}-${row.month}`] = row.override_amount;
        });
        return overrides;
    },

    /**
     * Set a P&L override value for a category+month
     * @param {number} categoryId - Category ID (use -1 for income tax)
     * @param {string} month - Month (YYYY-MM)
     * @param {number|null} amount - Override amount (null to remove override)
     */
    setPLOverride(categoryId, month, amount) {
        if (amount === null || amount === '') {
            this.db.run('DELETE FROM pl_overrides WHERE category_id = ? AND month = ?', [categoryId, month]);
        } else {
            this.db.run(
                'INSERT OR REPLACE INTO pl_overrides (category_id, month, override_amount) VALUES (?, ?, ?)',
                [categoryId, month, parseFloat(amount)]
            );
        }
        this.autoSave();
    },

    // ==================== PERSISTENCE ====================

    /**
     * Auto-save to IndexedDB
     */
    autoSave: Utils.debounce(async function() {
        await Database.saveToIndexedDB();
    }, 500),

    /**
     * Save database to IndexedDB
     * @returns {Promise<void>}
     */
    async saveToIndexedDB() {
        const data = this.db.export();
        const uint8Array = new Uint8Array(data);

        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.IDB_NAME, 1);

            request.onerror = () => reject(request.error);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.IDB_STORE)) {
                    db.createObjectStore(this.IDB_STORE);
                }
            };

            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction([this.IDB_STORE], 'readwrite');
                const store = transaction.objectStore(this.IDB_STORE);

                const putRequest = store.put(uint8Array, this.IDB_KEY);
                putRequest.onsuccess = () => {
                    console.log('Database auto-saved to IndexedDB');
                    resolve();
                };
                putRequest.onerror = () => reject(putRequest.error);
            };
        });
    },

    /**
     * Load database from IndexedDB
     * @returns {Promise<Uint8Array|null>}
     */
    async loadFromIndexedDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open(this.IDB_NAME, 1);

            request.onerror = () => reject(request.error);

            request.onupgradeneeded = (event) => {
                const db = event.target.result;
                if (!db.objectStoreNames.contains(this.IDB_STORE)) {
                    db.createObjectStore(this.IDB_STORE);
                }
            };

            request.onsuccess = (event) => {
                const db = event.target.result;
                const transaction = db.transaction([this.IDB_STORE], 'readonly');
                const store = transaction.objectStore(this.IDB_STORE);

                const getRequest = store.get(this.IDB_KEY);
                getRequest.onsuccess = () => {
                    resolve(getRequest.result || null);
                };
                getRequest.onerror = () => reject(getRequest.error);
            };
        });
    },

    /**
     * Export database to file
     * @returns {Blob} Database file blob
     */
    exportToFile() {
        const data = this.db.export();
        return new Blob([data], { type: 'application/x-sqlite3' });
    },

    /**
     * Import database from file
     * @param {ArrayBuffer} buffer - File content
     */
    async importFromFile(buffer) {
        const uint8Array = new Uint8Array(buffer);
        this.db = new this.SQL.Database(uint8Array);
        this.migrateSchema();
        await this.saveToIndexedDB();
    },

    // ==================== HELPERS ====================

    /**
     * Convert sql.js result rows to objects
     * @param {Object} result - sql.js result with columns and values
     * @returns {Array} Array of objects
     */
    rowsToObjects(result) {
        const { columns, values } = result;
        return values.map(row => {
            const obj = {};
            columns.forEach((col, index) => {
                obj[col] = row[index];
            });
            return obj;
        });
    }
};

// Export for use in other modules
window.Database = Database;
